<h1 class="unnumbered"
id="chapter-one---introduction-to-design-patterns">Chapter One -
Introduction to Design Patterns</h1>
<p>When designing software, bear in mind some of the following:</p>
<ul>
<li><p>Identify what stays the same and what varies</p>
<ul>
<li><p><span>Encapsulate whatever stays the same</span></p></li>
</ul></li>
<li><p>Program to an interface</p>
<ul>
<li><p><span>Define common methods in superclass and then implement
these individually within the class</span></p></li>
</ul></li>
<li><p>Favour composition over inheritance</p>
<ul>
<li><p>Understand when to use a HAS-A relationship instead of an IS-A
relationship</p></li>
<li><p>Construct objects from different classes over getting them to
inherit</p></li>
</ul></li>
</ul>
<p>Also, remember The Strategy Pattern Design Principle which is where a
family of algorithms is encapsulated and can be used interchangeably</p>
<h1 class="unnumbered" id="chapter-two---the-observer-pattern">Chapter
Two - The Observer Pattern</h1>
<p>The observer pattern is analogous to people subscribing to a
newsletter - we have a series of objects keeping tabs on any changes for
a particular subject</p>
<ul>
<li><p>We call the publisher of any new information the
<strong>subject</strong></p></li>
<li><p>We call the subscriber of any new information the
<strong>observer</strong></p></li>
<li><p>A more formal definition of the observer pattern is a
<strong>one-to-many dependency between objects so that when one object
changes state, all dependents are also notified</strong></p></li>
</ul>
<p>Java has a built-in API for creating observers/observables which has
some drawbacks:</p>
<ul>
<li><p>Observable has many crucial methods protected so you need to
always subclass</p></li>
<li><p>Observable is a class so its very hard to add more methods
underneath</p></li>
</ul>
<p>Another golden design principle to remember from this chapter is that
<strong>loosely coupled designs for interacting objects is
good</strong></p>
<h1 class="unnumbered"
id="chapter-three---the-decorator-pattern">Chapter Three - The Decorator
Pattern</h1>
<p>The decorator pattern is analogous to finding ways to easily
incorporate add-ons to a beverage from a coffee shop</p>
<ul>
<li><p>Sometimes, inheritance is not the best choice of design for an
object</p></li>
<li><p>Fundamentally, classes should be open for extension but closed
for modification</p>
<ul>
<li><p>Using decorators allows us to continue adding onto a class
appropriately</p></li>
</ul></li>
<li><p><span>More formally, decorators allow us to dynamically attach
extra functionality to a class</span></p></li>
</ul>
